<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="normalize.css" type="text/css" />
  <link rel="stylesheet" href="tutorial.css" type="text/css" />
</head>
<body>
<h1 id="pyfind-building-a-python-command-line-tool">PyFind: Building a Python command-line tool</h1>
<p>In this tutorial we will build a command-line tool in Python, and along the way learn about some modules that make this task easier.</p>
<h2 id="chapter-0-get-files-from-git">Chapter 0: Get files from Git</h2>
<p>Fork and clone the <a href="https://www.github.com/cruhland/pyfind/">starter repository</a>.</p>
<h2 id="chapter-1-setting-up">Chapter 1: Setting up</h2>
<p>We will build a Python version of the Unix <code>find</code> command. The <code>find</code> command searches through directory trees for files matching certain criteria.</p>
<p>To test our program, we'll need a directory tree. Luckily, we can create one using the <code>generate_files.py</code> program available in our repo:</p>
<pre><code>$ python generate_files.py</code></pre>
<p>This should create a directory <code>files</code> in the project directory that contains a bunch of randomly named files and directories. We'll run our PyFind program on this directory and compare its output with the Unix <code>find</code> command.</p>
<h2 id="chapter-2-introducing-find">Chapter 2: Introducing <code>find</code></h2>
<p>The simplest usage of <code>find</code> is to give it a single file name as an argument:</p>
<pre><code>$ find files</code></pre>
<p>Try this out on the <code>files</code> directory that you generated in Chapter 1. Notice that it prints out the name <code>files</code>, and then prints out all of the files and directories inside <code>files</code>, and all of the files and directories inside <em>those</em> directories, etc.</p>
<p>We want our PyFind program to do the same thing. To do this we will use two modules:</p>
<ol style="list-style-type: decimal">
<li><code>argparse</code> - For handling command-line arguments.</li>
<li><code>os</code> - For using operating system services, such as viewing directories.</li>
</ol>
<h2 id="chapter-3-the-argparse-module">Chapter 3: The <code>'argparse'</code> module</h2>
<p>What are command-line arguments? They are a list of whitespace-separated strings given after our program name when it is run. To see this, save the following program in <code>arguments.py</code>:</p>
<pre><code>import sys

if __name__ == &#39;__main__&#39;:
    print sys.argv</code></pre>
<p>Now, run it with some arguments, e.g.:</p>
<pre><code>$ python arguments.py These are the arguments.</code></pre>
<p>You should see output like:</p>
<pre><code>[&#39;arguments.py&#39;, &#39;These&#39;, &#39;are&#39;, &#39;the&#39;, &#39;arguments.&#39;]</code></pre>
<p>What just happened? In the Python code, we imported the <code>sys</code> module. This module defines a special list <code>argv</code> that stores the arguments to the program. The first element of the list (<code>sys.argv[0]</code>) is the name of the program, in this case <code>arguments.py</code>. The rest of the elements are the space-separated strings (if any) that we provided on the command line when the program was run. Try running <code>arguments.py</code> with different numbers of arguments to get more comfortable with the idea.</p>
<p>We have our PyFind program process its arguments using <code>sys.argv</code>, but this would require a lot of work. We would need to validate that all the arguments were specified correctly, and display error messages to the user if not. There are a lot of established conventions for command-line arguments that most programs obey, so we should follow those conventions to keep our users happy.</p>
<p>The best way to do this is the Python module <code>argparse</code>. It lets us describe what our arguments should look like, and it handles all the low-level details of parsing and validation. It also displays nicely-formatted help and error messages.</p>
<p>Now let's use <code>argparse</code> to get the directory to search in our PyFind program. Create a file <code>find.py</code> and give it the following contents:</p>
<pre><code>import argparse

def main():
    parser = argparse.ArgumentParser(description=&quot;Find files with Python&quot;)
    parser.add_argument(&quot;directory&quot;, help=&quot;the directory to search&quot;)
    args = parser.parse_args()

    print &quot;Searching in %s...&quot; % args.directory

if __name__ == &#39;__main__&#39;:
    main()</code></pre>
<p>Try running your program with different arguments to see what happens. Some suggestions:</p>
<pre><code>$ python find.py files
$ python find.py foo
$ python find.py foo bar
$ python find.py
$ python find.py -h
$ python find.py --help</code></pre>
<p>Notice how help text and error messages are appropriate for each of the argument combinations you tried. If we used <code>sys.argv</code> we would have had to handle all of that behavior ourselves.</p>
<h2 id="chapter-5-the-os-module">Chapter 5: The <code>'os'</code> module</h2>
<p>Now that we have our directory to search, we need to actually look through its contents and print them out. Getting information about files and directories is one of the services provided by the operating system. We can get access to these services from Python with the <code>os</code> module, and its submodule <code>os.path</code>.</p>
<p>There are a large number of functions in these two modules, how do we know which ones to call? We should first get a rough idea of how we are going to inspect the directory tree and print it out. Run the Unix <code>find</code> command again as a test; you should see something like the following:</p>
<pre><code>$ find files
files
files/glove
files/glove/ship
files/glove/finger
files/glove/cart
files/glove/cart/clock
files/glove/cart/clock/watch
files/glove/cart/heart
files/glove/cart/branch
files/glove/receipt
...</code></pre>
<p>Try to come up with a description of an algorithm in English that will produce this output. Peek at the answer below when you think you've figured it out:</p>
<div class="spoilers">
<p>For each of the items in a given directory, do the following:</p>
<ol style="list-style-type: decimal">
<li>Print out the path of the item</li>
<li>If the item is a directory, apply this algorithm to it
</div>
</li>
</ol>
<p>The interesting thing about this algorithm is that it refers to itself. This hints that it can be implemented using a recursive function, a function that calls itself. It turns out that a recursive function is the most straightforward way to process a directory tree, because the directories are nested inside each other over and over again. Nested data structures like directory trees are called <em>recursive data structures</em>, and <em>recursive functions</em> are usually the best way to process them. This is a specific case of a more general pattern: <strong>the structure of the algorithm should mimic the structure of the data that it operates on</strong>.</p>
<p>We still need to figure out which functions from the <code>os</code> and <code>os.path</code> modules we need to use to implement this algorithm. Think about each of the steps in the algorithm, and try to identify the pieces that require data from the filesystem. Check your work against the answer below before moving on:</p>
<div class="spoilers">
<ul>
<li>Get all the items in a given directory</li>
<li>Find or create the path of a directory item</li>
<li>Check if a directory item is itself a directory
</div>
</li>
</ul>
<p>The following functions might be useful for providing the missing pieces for your algorithm. You will not need all of them, but you should read their documentation to help you decide which to use:</p>
<ul>
<li><a href="http://docs.python.org/2/library/os.html#os.chdir">os.chdir(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.html#os.getcwd">os.getcwd()</a></li>
<li><a href="http://docs.python.org/2/library/os.html#os.listdir">os.listdir(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.abspath">os.path.abspath(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.basename">os.path.basename(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.dirname">os.path.dirname(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.isfile">os.path.isfile(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.isdir">os.path.isdir(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.join">os.path.join(path1[, path2[, ...]])</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.normpath">os.path.normpath(path)</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.relpath">os.path.relpath(path[, start])</a></li>
<li><a href="http://docs.python.org/2/library/os.path.html#os.path.split">os.path.split(path)</a></li>
</ul>
<p>Now we have everything we need to write our recursive directory-printing function in <code>find.py</code>. It should take the name of the directory to print as an argument. Call it on the directory name that you obtained using <code>argparse</code> in the previous chapter. To test your code, you can run the following commands:</p>
<pre><code>$ find files &gt; find.txt
$ python find.py files &gt; pyfind.txt
$ diff find.txt pyfind.txt</code></pre>
<p>These commands save the output of the Unix <code>find</code> command and your PyFind implementation to some text files, and then compare them. The <code>diff</code> command will show which lines of the output are different, which you can use to debug your code. If <code>diff</code> gives no output, then your code works! If you get stuck, peek at the reference implementation below:</p>
<div class="spoilers">

<pre><code>def visit(file_name, base_path=&quot;&quot;):
    full_path = os.path.join(base_path, file_name)
    print full_path
    if os.path.isdir(full_path):
        for name in os.listdir(full_path):
            visit(name, full_path)</code></pre>
</div>

</body>
</html>
